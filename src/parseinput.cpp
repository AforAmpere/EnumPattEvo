#include "arrayfuncs.h"
#include <iomanip>
#include <cstring>

unordered_map<string, string> helpmessages=
{
{"h", "-h [option1, option2,...]\n\n\
With no options, prints a list of possible flags. With provided options prints details about each flag.\n\n\
Example: -h p i\n\
Pulls up info for -p and -i commands."},
{"p", "-p {RLE1} [, RLE2,...]\n\n\
Searches with starting patterns corresponding to all of the inputs to -p, finding rules where all of the supplied patterns work simultaneously. \
Patterns are entered as headerless single-line RLEs. Without target patterns, searches will look for patterns which eventually repeat the starting \
pattern (and more if -e is on). If an input file is specified instead of an RLE, this will confine the rulespace like -i (see -h i for details), and \
also use the pattern as the initial pattern.\n\n\
Example 1: -p 'obo!' '3o$o$bo!'\n\
Sets two starting patterns, obo!, and 3o$o$bo!.\n\
Example: -p 'example.txt'\n\
Confines the rulespace to that matching the input file (example.txt)'s specifications, and also sets the pattern in the file as the starting pattern."},
{"b", "-b {width1, height1}, [width2, height2, width3, height3,...]\n\n\
Sets the bounding box dimensions for the search for pattern n. Number of pairs must equal number of patterns input. The bounding box in EPE \
is not fixed in place, and slides around with the pattern.\n\
Example: -b 5 5 4 7\n\
Sets the bounding boxes for the first two patterns to 5x5 and 4x7."},
{"g", "-g {depth1}, [depth2, depth3,...]\n\n\
Sets the maximum depth to take the search. A value of n will cap oscillators at period n for instance. Number must equal that of patterns.\n\n\
Example: -g 100 3\n\
Sets the generation depth for the first pattern at 100, and the second at 3."},
{"r", "-r {rule1} [, rule2,...]\n\n\
For setting the rulespace of the search. The number of rules depends on the overall space. Rulespaces are generated by generating a set of \
possible future states for each transition, and combining them. Picking two rules where transition t can lead to state 0 will have the set \
for that rule be {0}. If the two rules have the transition able to lead to state 0 and 1, the set will be {0,1}. For INT and similar rulespaces \
where transitions at maximum only have two options, this acts like a normal rulerange with a minrule and a maxrule.\n\n\
Example: -r 'B2a/S' 'B23/S1c'\n\
For INT, allows rules with anything in B23/S1c, but forces B2a transition, and everything else is off."},
{"t", "-t {target1} [, target2,...]\n\n\
Set target patterns for patterns to evolve into instead of themselves. The number of targets must be <= number of patterns. If there are n \
targets, they are applied to the first n patterns specified with -p.\n\n\
Example: -t '4o$o3bo$o$bo2bo!' 'b!'\n\
Sets the first pattern's target to the LWSS, and the second to an empty pattern."},
{"e", "-e [flag1, flag2, ...]\n\n\
Set whether patterns that start from the initial pattern but evolve into some other oscillatory pattern are reported as well. With no extra arguments \
sets this flag for all patterns. With arguments, set to 0 or 1 (on or off) for each pattern, must be the same number of flags as there are patterns. \
Not compatible with -t. If both are on, -t takes preference. -e will not be complete, unlike a search without it, as it still excludes patterns that \
evolve into more symmetric states (as those can never be solutions for pure -p searches). This can be rectified with --nosymm, (and --noexp, but not \
recommended currently).\n\n\
Example 1: -e\n\
Allows said reporting to happen for all patterns.\n\
Example 2: -e 0 0 1 0\n\
Allows said reporting to happen for the third pattern, but no others (if there are 4 starting patterns)."},
{"m", "-m [flag1, flag2, ...]\n\n\
Set whether patterns reported must move during their evolution. With no extra arguments sets this flag for all patterns. With arguments, \
set to 0 or 1 (on or off) for each pattern, must be the same number of flags as there are patterns. Not compatible with patterns that also use -t. \
If both are on, -t takes preference.\n\n\
Example 1: -m\n\
Allows said reporting to happen for all patterns.\n\
Example 2: -m 0 0 1 0\n\
Allows said reporting to happen for the third pattern, but no others (if there are 4 starting patterns)."},
{"nosymm", "--nosymm [flag1, flag2, ...]\n\n\
Set whether patterns are allowed to change symmetries during evolution. With no extra arguments sets this flag for all patterns. With arguments, \
set to 0 or 1 (change is not allowed versus is allowed) for each pattern, must be the same number of flags as there are patterns. Not compatible \
with patterns that also use -t. -t always effectively uses this, since it has alternate symmetry criteria. By default, symmetry is not allowed to \
change for non -t patterns.\n\n\
Example 1: --nosymm\n\
Allows said reporting to happen for all patterns.\n\
Example 2: --nosymm 0 0 1 0\n\
Allows said reporting to happen for the third pattern, but no others (if there are 4 starting patterns)."},
{"noexp", "--noexp [flag1, flag2, ...]\n\n\
Set whether explosion detection is turned off for a given pattern. With no extra arguments sets this flag for all patterns. With arguments, \
set to 0 or 1 (explosion frontends are not allowed versus are allowed) for each pattern, must be the same number of flags as there are patterns. Not \
compatible with patterns that also use -t. This flag will be ignored for those patterns (currently).\n\n\
"},
{"i", "-i {file1} [, file2,...]\n\n\
Confine the rulespace to that matching the pattern in the file, to the number of generations at the top of it. Be sure if multiple files are used, \
or if used in conjunction with -r to not give conflicting rulespaces. Input files are formatted as a number of generations to match to on the first \
line, and then the RLE (including the header) pasted below. example.txt is an example, matching the b-heptomino in B3/S23 for 17 gens. Note: -i does NOT\
set the starting pattern. To use a file to do that, use -p with the filename. Also, -i will only work with patterns whose evolution in the generations \
specified is contained within a 1000x1000 box.\n\n\
Example: -i 'example.txt'\n\
Confines the rulespace to that matching the input file (example.txt)'s specifications."},
{"f", "-f {file}\n\n\
Specify the output file to send results to. If none is specified, EPEOutput.txt will be the default.\n\n\
Example: -f 'newoutput.txt'\n\
Directs results to newoutput.txt."},
{"a", "-a\n\n\
If on, sets output to append to results file instead of resetting it every time."},
{"s", "-s {file}\n\n\
Specify the output file to save the current state in the search trees to. Useful for when you want to cancel a search to resume later.\n\n\
Example: -s 'savedata.txt'\n\
Saves state to savedata.txt."},
{"l", "-l {file}\n\n\
Specify the output file to load from.\n\n\
Example: -l 'savedata.txt'\n\
Loads progress from savedata.txt.\n\n\
-l {depth list}\n\n\
Inputting a list of depths will start the search at the position specified.\n\n\
Example: -l '1 6 7 31'\n\
Starts at [1/n1], [6/n2], [7/n3], [31/n4]."},
{"5s", "--5s [foldername]\n\n\
If on, turns on 5s mode, where patterns that are output (without alternative targets with -t) are only output if they are the current smallest of that speed \
in the search. 'Speed' here also includes oscillators. Can significantly cut down on output volume if all you care about is different speeds and periods. \
Be sure that you are loading a database from files in the same rulespace. If a folder is given, it attempts to load speeds from the 3 5s database files in \
that folder.\n\n\
Example 1: --5s\n\
Turns on 5s mode.\n\
Example 2: --5s {path to your copy of the 5s database's folder}\n\
Loads the speeds from the 5s database, and turns on 5s mode."},
{"mp", "--mp {period}\n\n\
Sets a minimum period that results can be output as.\n\n\
Example: --mp 3\n\
No oscillators or ships under p3 will be reported."},
{"filter", "--filter {stringofineqs1} [, stringofineqs2,...]\n\n\
Sets certain criteria to filter outputs with, population, displacements, and commonness are currently supported. Filtering on patterns without -t targets \
will filter results during their entire period. Filters are specified by giving an inequality to confine the parameter in. \
For example, confining the displacement in the x direction between -5 and 6 could be done like -5<=dx<=6 or -6<dx<7, or -6<dx<=6 as some of the ways. The \
parameters of population, displacement in x, and displacement in y are represented by p, dx, dy, and c. Inequalities must be specified with no spaces. \
The nth filter applies to the nth pattern. To specify filters for later patterns but not earlier ones, just give '' as a filter for the earlier.\n\n\
Example: --filter 'p<10 dx<-1' '' 'dy>=3'\n\
Results for the first pattern must have a minimum pop <10 and a displacement through its period (or end displacement for -t) more than -1 in the x direction. \
For the second no filter is specified. For the third, it must move by 3 or more in the y direction."},
{"prune", "--prune {stringofineqs1} [, stringofineqs2,...]\n\n\
Sets certain criteria to enforce during the search, i.e. the search backtracks if it violates the criteria specified. Population, displacements, and \
commonness are currently supported. This is specified by giving an inequality to confine the parameter in. For example, confining the displacement in \
the x direction between -5 and 6 could be done like -5<=dx<=6 or -6<dx<7, or -6<dx<=6 as some of the ways. \
The parameters of population, displacement in x, displacement in y, and commonness are represented by p, dx, dy, and c. Inequalities must be specified with \
no spaces. The nth prune applies to the nth pattern. To specify prunings for later patterns but not earlier ones, just give '' for the earlier.\n\n\
Example: --prune 'p<10 dx<11' '' 'dy>=-1'\n\
At all times for the first pattern must have a pop <10 and a displacement less than 11 in the x direction. \
For the second no pruning is specified. For the third, it must have moved by -1 or more in the y direction from the starting position at all times."},
{"confslid", "--confslid {RLE1} [, RLE2,...]\n\n\
Forces the pattern to be contained in the region specified in the RLE provided. This means that all on cells must be in areas where the mask RLE also has \
cells that are not state 0. In this case, the mask RLE moves along with the bounding box, the position of which is defined by the top left corner. Input files \
can be used as well.\n\n\
Example: --confslid '3o$5o$3o!'\n\
Forces the pattern to be contained within the specified shape, which moves around with the pattern."},
{"sliceslid", "--sliceslid {RLE1} [, RLE2,...]\n\n\
Pattern matching is only checked within the region specified by the RLE provided. This means that the desired end pattern (either the start for non -t runs, \
or whatever the target is for -t runs) is only checked to equal the current if the cells in the RLE are on at that location. This can be used for searches \
where only part of the pattern needs to be the same, such as puffers, rakes, or replicators. In this case, the mask RLE moves along with the bounding box, the \
position of which is defined by the top left corner. Input files can be used as well.\n\n\
Example: --sliceslid '3o$5o$3o!'\n\
Only checks if the final pattern equals the target inside the pattern in the RLE."},
{"confstat", "--confstat {RLE1, offx, offy} [, RLE2, offx, offy...]\n\n\
Forces the pattern to be contained in the region specified in the RLE provided. This means that all on cells must be in areas where the mask RLE also has \
cells that are not state 0. In this case, the mask RLE stays in the same place. An offset is specified to give where the top left corner of the mask should \
be in relation to the top left corner of the initial bounding box of the starting pattern. Input files can be used as well.\n\n\
Example: --confstat '3o$5o$3o!' -1 -2'\n\
Forces the pattern to be contained within the specified shape, the mask is offset left by 1 and up by 2."},
{"slicestat", "--slicestat {RLE1, offx, offy} [, RLE2, offx, offy...]\n\n\
Pattern matching is only checked within the region specified by the RLE provided. This means that the desired end pattern (either the start for non -t runs, \
or whatever the target is for -t runs) is only checked to equal the current if the cells in the RLE are on at that location. This can be used for searches \
where only part of the pattern needs to be the same, such as puffers, rakes, or replicators. In this case, the mask RLE stays in place, the \
position of which is defined by the top left corner, and the offset. An offset is specified to give where the top left corner of the mask should \
be in relation to the top left corner of the initial bounding box of the starting pattern. Input files can be used as well.\n\n\
Example: --slicestat '3o$5o$3o!' -1 -2'\n\
Only checks if the final pattern equals the target inside the pattern in the RLE, the mask is offset left by 1 and up by 2."},
{"report", "--report {interval}\n\n\
Sets the frequency in branches traversed in which to output to stdout and send the results to the file.\n\n\
Example: --report 10000\n\
Report on progress every 10000 branches, and output to a file the latest results."},
{"rand", "--rand {seed}\n\n\
Makes the branch ordering semi-random, based on the seed provided.\n\n\
Example: --seed 12345\n\
Sets the random seed to 12345."},

};

string input_file(string filename, bool setrule=true)
{
    ifstream file;
    string runtos;
    int runto=-1;
    string header;
    stringstream rlebuff;
    rlebuff.str("");
    file.open(filename);
    if(!(file))
    {
        cout<<"Invalid filename provided."<<endl;
        exit(1);
    }
    getline(file, runtos);
    try
    {
        runto = stoi(runtos);
    }
    catch(invalid_argument const& ex)
    {
        if(!setrule)
        {
            file.close();
            file.open(filename);
        }
        else
        {
            cout<<"Invalid or no number provided in input file for generation count, exiting."<<endl;
            exit(1);
        }
    }
    getline(file, header);
    if(file)
    {
        rlebuff<<file.rdbuf();
    };
    file.close();
    if(!setrule) return rlebuff.str();
    string t;
    stringstream he = stringstream(header);
    int n=0;
    bool flux=false;

    //int w, h;
    string rule;

    while(getline(he, t, ' '))
    {
        if(t=="=")
        {
            n++;
            flux=true;
        }
        else
        {
            if(flux==true)
            {
                switch(n)
                {
                    case 1:
                    {
                        stoi(t.substr(0,t.size()-1));
                        break;
                    }
                    case 2:
                    {
                        stoi(t.substr(0,t.size()-1));
                        break;
                    }
                    case 3:
                    {
                        rule=t;
                        break;
                    }
                    default:
                    {
                        break;
                    }
                }
            }
            flux=false;
        }
    }
    rule = rule.substr(0,rule.find_last_not_of("\n\r\t")-rule.find_first_not_of("\n\r\t")+1);
    auto prsdr = vector<RuleRep>({parse_rule(rule)});
    auto rspac = rulespace_from_rules(prsdr);

    vector<CellArray> arrs;
    arrs.resize(2, CellArray(1000,1000,-1));
    set_grid(arrs[0],rlebuff.str());
    TransSetArray tsa={0};

    for(int g=0;g<runto;g++)
    {
        arrs[g%2].generate_trans_array(maxspace,tsa);
        evolve(rspac,arrs[g%2],arrs[(g+1)%2]);
    }
    #ifdef LINKED
    for(int j=0;j<TRANSCOUNT;j++)
    {
        if(tsa[j]==1)
        {
            queue<pair<int,int>>& l = linked(j,-rspac[j][0]);
            pair<int,int> p;
            while(!l.empty())
            {
                p=l.front();
                l.pop();
                if(tsa[p.first]==1)
                {
                    if(p.second != -rspac[p.first][0])
                    {
                        cout<<"Discrepancy in evolution on transition "<<j<<endl;
                        exit(1);
                    }
                }
                else
                {
                    tsa[p.first] = 1;
                    rspac[p.first][0]=-p.second;
                }
            }
        }
    }
    #endif
    for(int j=0;j<TRANSCOUNT;j++)
    {
        if(tsa[j]==1)
        {
            if(OptionState::incomingrulespace[j][0]>1)
            {
                OptionState::incomingrulespace[j][0]=rspac[j][0];
            }
            else
            {
                if(OptionState::incomingrulespace[j][0]!=rspac[j][0])
                {
                    cout<<"Rulespaces are conflicting."<<endl;
                    exit(1);
                }
            }
        }
    }
    return rlebuff.str();
}

void load_5s(unordered_map<string,int>& table, string folder)
{
    ifstream diag, ortho, obliq;
    diag.open(folder+"/"+"Diagonal ships.sss.txt");
    ortho.open(folder+"/"+"Orthogonal ships.sss.txt");
    obliq.open(folder+"/"+"Oblique ships.sss.txt");

    if(!(diag))
    {
        cout<<"Error in attempting to load ships. Make sure path is correct."<<endl;
    }
    string l;
    while(getline(diag, l))
    {
        int n=0;
        int b=0;
        int e=0;
        int p=0;
        l=l.substr(0,l.size()-1);
        for(size_t i=0;i<l.size();i++)
        {
            if(l[i]==',')
            { 
                n++;
                if(n==1) p=stoi(l.substr(0,i));
                if(n==2) b = i+2;
                if(n==5) e = i;
            }
        }
        table[l.substr(b,e-b)]=p;
    }
    while(getline(ortho, l))
    {
        int n=0;
        int b=0;
        int e=0;
        int p=0;
        l=l.substr(0,l.size()-1);
        for(int i=0;i<l.size();i++)
        {
            if(l[i]==',')
            { 
                n++;
                if(n==1) p=stoi(l.substr(0,i));
                if(n==2) b = i+2;
                if(n==5) e = i;
            }
        }
        table[l.substr(b,e-b)]=p;
    }
    while(getline(obliq, l))
    {
        int n=0;
        int b=0;
        int e=0;
        int p=0;
        l=l.substr(0,l.size()-1);
        for(int i=0;i<l.size();i++)
        {
            if(l[i]==',')
            { 
                n++;
                if(n==1) p=stoi(l.substr(0,i));
                if(n==2) b = i+2;
                if(n==5) e = i;
            }
        }
        table[l.substr(b,e-b)]=p;
    }
}

pair<int,int> bounds(pair<vector<string>,vector<int>>& chunks, int l, int u)
{
    pair<int,int> bounds;
    vector<string> s = chunks.first;
    bounds.first=SMOLL;
    bounds.second=LORGE;
    int tmp = 0;
    bool namocc=false;
    for(int i=l;i<u;i++)
    {
        if(chunks.second[i]==1)
        {
            tmp=stoi(s[i]);
        }
        if(chunks.second[i]==0)
        {
            if(s[i]=="="||s[i]=="==")
            {
                if(namocc)
                {
                    tmp=stoi(s[i+1]);
                }
                bounds.first=tmp;
                bounds.second=tmp;
                return bounds;
            }
            else if(s[i]=="<")
            {
                if(namocc)
                {
                    tmp=stoi(s[i+1]);                  
                    bounds.second=tmp-1;
                    return bounds;
                }
                else
                {
                    bounds.first=tmp+1;
                }
            }
            else if(s[i]=="<="||s[i]=="=<")
            {
                if(namocc)
                {
                    tmp=stoi(s[i+1]);                  
                    bounds.second=tmp;
                    return bounds;
                }
                else
                {
                    bounds.first=tmp;
                }
            }
            else if(s[i]==">")
            {
                if(namocc)
                {
                    tmp=stoi(s[i+1]);                  
                    bounds.first=tmp+1;
                    return bounds;
                }
                else
                {
                    bounds.second=tmp-1;
                }
            }
            else if(s[i]==">="||s[i]=="=>")
            {
                if(namocc)
                {
                    tmp=stoi(s[i+1]);                  
                    bounds.first=tmp;
                    return bounds;
                }
                else
                {
                    bounds.second=tmp;
                }
            }
        }
        if(chunks.second[i]==2)
        {
            namocc=true;
        }
    }
    return bounds;
}

pair<vector<string>,vector<int>> chunk(string toparse)
{
    int cat=-1;
    vector<string> chunks;
    vector<int> chunk_num;
    if(toparse.size()==0) return pair<vector<string>,vector<int>>{chunks,chunk_num};
    for(char c:toparse)
    {
        if(c==' ')
        {
            if(cat!=3)
            {
                chunks.push_back("");
                chunk_num.push_back(3);
            }
            cat=3;
        }
        else if(c=='>'||c=='<'||c=='=')
        {
            if(cat!=0)
            {
                chunks.push_back("");
                chunk_num.push_back(0);
            }
            chunks[chunks.size()-1]+=c;
            cat=0;
        }
        else if((c>='0'&&c<='9')||c=='-')
        {
            if(cat!=1)
            {
                chunks.push_back("");
                chunk_num.push_back(1);
            }
            chunks[chunks.size()-1]+=c;
            cat=1;
        }
        else
        {
            if(cat!=2)
            {
                chunks.push_back("");
                chunk_num.push_back(2);
            }
            chunks[chunks.size()-1]+=c;
            cat=2;
        }
    }
    return pair<vector<string>,vector<int>>{chunks,chunk_num};
}

void parse_input(int argc, char** argv, bool loading=false)
{
    OptionState::incomingrulespace=maxspace;
    vector<vector<string>> opts;
    for(int i=1; i<argc; i++)
    {
        if(argv[i][0]=='-' && string(argv[i]).size()>1 && (argv[i][1]<'0'|| argv[i][1]>'9'))
        {
            opts.push_back(vector<string>());
        }
        if(opts.size())
        {
            opts.back().push_back(argv[i]);
        }
        //Loading from file
        if(!loading && opts.back().size()>1&&opts.back()[0]=="-l")
        {
            ifstream loadfile(opts.back()[1]);
            string commands, g;
            stringstream tmp;
            vector<string> strs;
            if(!(loadfile))
            {
                continue;
            }
            getline(loadfile, commands);
            OptionState::loadedargv=commands;
            tmp = stringstream(commands);
            while(tmp>>quoted(g, '\''))
            {
                strs.push_back(g);
            }
            int nargc=strs.size()+2;
            char** nargv = new char*[nargc];
            for(size_t j=0;j<nargc-2;j++)
            {
                int q = strs[j].size()+1;
                nargv[j] = new char[q];
                strcpy(nargv[j],strs[j].data());
            }
            getline(loadfile, g);
            g = g;
            nargv[nargc-2] = new char[3];
            nargv[nargc-1] = new char[g.size()+1];
            strcpy(nargv[nargc-2],"-l");
            strcpy(nargv[nargc-1],g.data());
            parse_input(nargc, nargv, loading=true);
            loadfile.close();
            for(int j=0;j<nargc;j++) delete[] nargv[j];
            delete[] nargv;
            return;
        }
    }

    for(auto v:opts)
    {
        if(v[0]=="-p")
        {
            for(int i=1; i<v.size();i++)
            {
                ifstream testpattfile(v[i]);
                if(!(testpattfile))
                {
                    OptionState::startingpatterns.push_back(v[i]);
                }
                else
                {
                    testpattfile.close();
                    OptionState::startingpatterns.push_back(input_file(v[i]));
                }
            }
        }

        else if(v[0]=="-t")
        {
            for(int i=1;i<v.size();i++)
            {
                ifstream testpattfile(v[i]);
                if(!(testpattfile))
                {
                    OptionState::targetpatterns.push_back(v[i]);
                }
                else
                {
                    testpattfile.close();
                    OptionState::targetpatterns.push_back(input_file(v[i], false));
                }
            }
        }

        else if(v[0]=="-b")
        {
            for(int i=1; i<v.size();i++)
            {
                if(i%2==1)
                    OptionState::xdims.push_back(stoi(v[i]));
                else
                    OptionState::ydims.push_back(stoi(v[i]));
            }
        }

        else if(v[0]=="-g")
        {
            for(int i=1; i<v.size();i++)
            {
                OptionState::gendepths.push_back(stoi(v[i]));
            }
        }
        
        else if(v[0]=="-r")
        {
            for(int i=1; i<v.size();i++)
            {
                OptionState::rulespace.push_back(v[i]);
            }
        }

        else if(v[0]=="-e")
        {
            OptionState::allow_evolve.push_back(-1);
            for(int i=1; i<v.size();i++)
            {
                OptionState::allow_evolve.push_back(stoi(v[i]));
            }
        }

        else if(v[0]=="-m")
        {
            OptionState::enforce_move.push_back(-1);
            for(int i=1; i<v.size();i++)
            {
                OptionState::enforce_move.push_back(stoi(v[i]));
            }
        }

        else if(v[0]=="--mp")
        {
            OptionState::minperiod=stoi(v[1]);
        }

        else if(v[0]=="-f")
        {
            OptionState::filename=v[1];
        }

        else if(v[0]=="--report")
        {
            OptionState::reporting_interval=stoi(v[1]);
        }

        else if(v[0]=="--5s")
        {
            OptionState::sssssmode=true;
            if(v.size()==2)
            {
                OptionState::sssssfolder=v[1];
            }
        }

        else if (v[0]=="-i")
        {
            for(int i=1; i<v.size();i++)
            {
                input_file(v[i]);
            }
        }

        else if (v[0]=="-l")
        {
            stringstream s(v[1]);
            int i=0;
            while(s>>i) 
            {
                OptionState::startingbranchoffset.push_back(i);
            }
        }

        else if (v[0]=="-s")
        {
            OptionState::savefile=v[1];
        }

        else if(v[0]=="--prune")
        {
            for(int i=1; i<v.size();i++)
            {
                OptionState::prune_minpop.push_back(0);
                OptionState::prune_maxpop.push_back(LORGE);
                OptionState::prune_mindispx.push_back(SMOLL);
                OptionState::prune_maxdispx.push_back(LORGE);
                OptionState::prune_mindispy.push_back(SMOLL);
                OptionState::prune_maxdispy.push_back(LORGE);
                OptionState::prune_mincomm.push_back(0);
                OptionState::prune_maxcomm.push_back(TRANSCOUNT);
                if(v[i].size()==0) continue;
                auto q = chunk(v[i]);
                int n2 = 0;
                int pos2=0;
                int z=0;
                for(int j=0;j<q.first.size();j++)
                {
                    if(q.second[j]==2) 
                    {
                        n2++;
                        pos2=j;
                    }
                    if(q.second[j]==3)
                    {
                        n2=0;
                        auto b = bounds(q, z, j);
                        if(q.first[pos2]=="p")
                        {
                            OptionState::prune_minpop[i-1]=max(OptionState::prune_minpop[i-1],b.first);
                            OptionState::prune_maxpop[i-1]=min(OptionState::prune_maxpop[i-1],b.second);
                        }
                        else if(q.first[pos2]=="dx")
                        {
                            OptionState::prune_mindispx[i-1]=max(OptionState::prune_mindispx[i-1],b.first);
                            OptionState::prune_maxdispx[i-1]=min(OptionState::prune_maxdispx[i-1],b.second);
                        }
                        else if(q.first[pos2]=="dy")
                        {
                            OptionState::prune_mindispy[i-1]=max(OptionState::prune_mindispy[i-1],b.first);
                            OptionState::prune_maxdispy[i-1]=min(OptionState::prune_maxdispy[i-1],b.second);
                        }
                        else if(q.first[pos2]=="c")
                        {
                            OptionState::prune_mincomm[i-1]=max(OptionState::prune_mincomm[i-1],b.first);
                            OptionState::prune_maxcomm[i-1]=min(OptionState::prune_maxcomm[i-1],b.second);
                        }
                        z=j;
                    }
                    if(n2>1)
                    {
                        cout<<"Too many things in number "<<i<<" inequality or wrong format."<<endl;
                        exit(1);
                    }
                }
                auto b = bounds(q,z,q.first.size());
                if(q.first[pos2]=="p")
                {
                    OptionState::prune_minpop[i-1]=max(OptionState::prune_minpop[i-1],b.first);
                    OptionState::prune_maxpop[i-1]=min(OptionState::prune_maxpop[i-1],b.second);
                }
                else if(q.first[pos2]=="dx")
                {
                    OptionState::prune_mindispx[i-1]=max(OptionState::prune_mindispx[i-1],b.first);
                    OptionState::prune_maxdispx[i-1]=min(OptionState::prune_maxdispx[i-1],b.second);
                }
                else if(q.first[pos2]=="dy")
                {
                    OptionState::prune_mindispy[i-1]=max(OptionState::prune_mindispy[i-1],b.first);
                    OptionState::prune_maxdispy[i-1]=min(OptionState::prune_maxdispy[i-1],b.second);
                }
                else if(q.first[pos2]=="c")
                {
                    OptionState::prune_mincomm[i-1]=max(OptionState::prune_mincomm[i-1],b.first);
                    OptionState::prune_maxcomm[i-1]=min(OptionState::prune_maxcomm[i-1],b.second);
                }
            }
        }

        else if(v[0]=="--filter")
        {
            for(int i=1; i<v.size();i++)
            {
                OptionState::filter_minpop.push_back(0);
                OptionState::filter_maxpop.push_back(LORGE);
                OptionState::filter_mindispx.push_back(SMOLL);
                OptionState::filter_maxdispx.push_back(LORGE);
                OptionState::filter_mindispy.push_back(SMOLL);
                OptionState::filter_maxdispy.push_back(LORGE);
                OptionState::filter_mincomm.push_back(0);
                OptionState::filter_maxcomm.push_back(TRANSCOUNT);
                if(v[i].size()==0) continue;
                auto q = chunk(v[i]);
                int n2 = 0;
                int pos2=0;
                int z=0;
                for(int j=0;j<q.first.size();j++)
                {
                    if(q.second[j]==2) 
                    {
                        n2++;
                        pos2=j;
                    }
                    if(q.second[j]==3)
                    {
                        n2=0;
                        auto b = bounds(q, z, j);
                        if(q.first[pos2]=="p")
                        {
                            OptionState::filter_minpop[i-1]=max(OptionState::filter_minpop[i-1],b.first);
                            OptionState::filter_maxpop[i-1]=min(OptionState::filter_maxpop[i-1],b.second);
                        }
                        else if(q.first[pos2]=="dx")
                        {
                            OptionState::filter_mindispx[i-1]=max(OptionState::filter_mindispx[i-1],b.first);
                            OptionState::filter_maxdispx[i-1]=min(OptionState::filter_maxdispx[i-1],b.second);
                        }
                        else if(q.first[pos2]=="dy")
                        {
                            OptionState::filter_mindispy[i-1]=max(OptionState::filter_mindispy[i-1],b.first);
                            OptionState::filter_maxdispy[i-1]=min(OptionState::filter_maxdispy[i-1],b.second);
                        }
                        else if(q.first[pos2]=="c")
                        {
                            OptionState::filter_mincomm[i-1]=max(OptionState::filter_mincomm[i-1],b.first);
                            OptionState::filter_maxcomm[i-1]=min(OptionState::filter_maxcomm[i-1],b.second);
                        }
                        z=j;
                    }
                    if(n2>1)
                    {
                        cout<<"Too many things in number "<<i<<" inequality or wrong format."<<endl;
                        exit(1);
                    }
                }
                auto b = bounds(q,z,q.first.size());
                if(q.first[pos2]=="p")
                {
                    OptionState::filter_minpop[i-1]=max(OptionState::filter_minpop[i-1],b.first);
                    OptionState::filter_maxpop[i-1]=min(OptionState::filter_maxpop[i-1],b.second);
                }
                else if(q.first[pos2]=="dx")
                {
                    OptionState::filter_mindispx[i-1]=max(OptionState::filter_mindispx[i-1],b.first);
                    OptionState::filter_maxdispx[i-1]=min(OptionState::filter_maxdispx[i-1],b.second);
                }
                else if(q.first[pos2]=="dy")
                {
                    OptionState::filter_mindispy[i-1]=max(OptionState::filter_mindispy[i-1],b.first);
                    OptionState::filter_maxdispy[i-1]=min(OptionState::filter_maxdispy[i-1],b.second);
                }
                else if(q.first[pos2]=="c")
                {
                    OptionState::filter_mincomm[i-1]=max(OptionState::filter_mincomm[i-1],b.first);
                    OptionState::filter_maxcomm[i-1]=min(OptionState::filter_maxcomm[i-1],b.second);
                }
            }
        }

        else if(v[0]=="-a")
        {
            OptionState::append=true;
        }

        else if(v[0]=="--confslid")
        {
            for(int i=1;i<v.size();i++)
            {
                ifstream testpattfile(v[i]);
                if(!(testpattfile))
                {
                    OptionState::slidingmask.push_back(v[i]);
                }
                else
                {
                    testpattfile.close();
                    OptionState::slidingmask.push_back(input_file(v[i], false));
                }
            }
        }

        else if(v[0]=="--confstat")
        {
            for(int i=1;i<v.size();i++)
            {
                switch(i%3)
                {
                    case 1:
                    {
                        ifstream testpattfile(v[i]);
                        if(!(testpattfile))
                        {
                            OptionState::staticmask.push_back(v[i]);
                        }
                        else
                        {
                            testpattfile.close();
                            OptionState::staticmask.push_back(input_file(v[i], false));
                        }
                        OptionState::staticmaskoff.push_back({0,0});
                        break;
                    }
                    case 2:
                    {
                        OptionState::staticmaskoff[i/3].first=stoi(v[i]);
                        break;
                    }
                    case 0:
                    {
                        OptionState::staticmaskoff[i/3-1].second=stoi(v[i]);
                        break;
                    }
                }
            }
        }

        else if(v[0]=="--sliceslid")
        {
            for(int i=1;i<v.size();i++)
            {
                ifstream testpattfile(v[i]);
                if(!(testpattfile))
                {
                    OptionState::slidingcomp.push_back(v[i]);
                }
                else
                {
                    testpattfile.close();
                    OptionState::slidingcomp.push_back(input_file(v[i], false));
                }
            }
        }

        else if(v[0]=="--slicestat")
        {
            for(int i=1;i<v.size();i++)
            {
                switch(i%3)
                {
                    case 1:
                    {
                        ifstream testpattfile(v[i]);
                        if(!testpattfile.is_open())
                        {
                            OptionState::staticcomp.push_back(v[i]);
                        }
                        else
                        {
                            testpattfile.close();
                            OptionState::staticcomp.push_back(input_file(v[i], false));
                        }
                        OptionState::staticcompmaskoff.push_back({0,0});
                        break;
                    }
                    case 2:
                    {
                        OptionState::staticcompmaskoff[i/3].first=stoi(v[i]);
                        break;
                    }
                    case 0:
                    {
                        OptionState::staticcompmaskoff[i/3-1].second=stoi(v[i]);
                        break;
                    }
                }
            }
        }

        else if(v[0]=="--rand")
        {
            OptionState::randseed=stoi(v[1]);
        }

        else if(v[0]=="--nosymm")
        {
            OptionState::nosymm.push_back(-1);
            for(int i=1; i<v.size();i++)
            {
                OptionState::nosymm.push_back(stoi(v[i]));
            }
        }

        else if(v[0]=="--noexp")
        {
            OptionState::noexp.push_back(-1);
            for(int i=1; i<v.size();i++)
            {
                OptionState::noexp.push_back(stoi(v[i]));
            }
        }

        else if(v[0]=="-h")
        {
            for(int i=0; i<v.size();i++)
            {
                OptionState::help.push_back(v[i]);
            }
        }

        else
        {
            cout<<"Unrecognized command "<<v[0]<<"."<<endl;
            exit(1);
        }
    }
}

void binary_option_after(vector<int>& option,string name,bool enforce=true)
{
    if(option.size()) 
    {
        option.erase(option.begin());
        if(option.size()==0)
        {
            option.resize(OptionState::startingpatterns.size(),1);
        }
    }
    else
    {
        option.resize(OptionState::startingpatterns.size(),0);
    }
    if(!enforce) return;
    for(int i=0;i<OptionState::startingpatterns.size();i++)
    {
        if(option[i]&&i<OptionState::targetpatterns.size())
        {
            cout<<"The "<<name<<" flag cannot be on for patterns with a -t target."<<endl;
            exit(1);
        }
    }
}

void check_parsed()
{
    int pattcount = OptionState::startingpatterns.size();
    int xcount = OptionState::xdims.size();
    int ycount = OptionState::ydims.size();
    int gencount = OptionState::gendepths.size();
    int targetcount = OptionState::targetpatterns.size();
    int evolvecount = OptionState::allow_evolve.size();
    int movecount = OptionState::enforce_move.size();
    int helpcount = OptionState::help.size();

    if(helpcount!=0)
    {
        if(helpcount==1)
        {
            cout<<"Options are -p, -t, -b, -g, -r, -e, -m, -i, -f, -a, -s, -l, --5s, --mp, --filter, --prune, --report, --nosymm, --noexp, --confslid, --confstat, --sliceslid, --slicestat, --rand, and -h at the moment. Use -h [option1, option2...] to show info on those options. -h h is an example."<<endl;
        }
        else
        {
            for(int i=1;i<OptionState::help.size();i++)
            {
                cout<<helpmessages[OptionState::help[i]]<<endl;
                if(i!=OptionState::help.size()-1)
                {
                    cout<<endl<<endl;
                }
            }
        }
    }
    else if(pattcount==0)
    {
        cout<<"There needs to be at least one input pattern."<<endl;
    }
    else if(targetcount>pattcount)
    {
        cout<<"The number of target patterns must be <= the number of starting patterns."<<endl;
    }
    else if(evolvecount!=pattcount+1 && evolvecount!=1 && evolvecount!=0)
    {
        cout<<"The number of specified evolution flags must be 0 or the number of starting patterns."<<endl;
    }
    else if(movecount!=pattcount+1 && movecount!=1 && movecount!=0)
    {
        cout<<"The number of specified movement flags must be 0 or the number of starting patterns."<<endl;
    }
    else if((xcount!=pattcount&&xcount!=1)||(ycount!=pattcount&&ycount!=1)||xcount!=ycount)
    {
        cout<<"The number of bounding box dimension pairs must be 1 or match the pattern count."<<endl;
    }
    else if(gencount!=pattcount&&gencount!=1)
    {
        cout<<"The number of generation depths must match the pattern count."<<endl;
    }
    else
    {
        if(xcount==1)
        {
            OptionState::xdims.resize(pattcount,OptionState::xdims[0]);
            OptionState::ydims.resize(pattcount,OptionState::ydims[0]);
        }

        if(gencount==1)
        {
            OptionState::gendepths.resize(pattcount,OptionState::gendepths[0]);
        }

        binary_option_after(OptionState::allow_evolve,"-e");
        binary_option_after(OptionState::enforce_move,"-m", false);
        binary_option_after(OptionState::nosymm,"--nosymm");
        binary_option_after(OptionState::noexp,"--noexp");

        while(OptionState::slidingmask.size()&&OptionState::slidingmask.size()<OptionState::startingpatterns.size()){OptionState::slidingmask.push_back("");}
        while(OptionState::staticmask.size()&&OptionState::staticmask.size()<OptionState::startingpatterns.size()){OptionState::staticmask.push_back("");}

        OptionState::prune_minpop.resize(pattcount,0);
        OptionState::prune_maxpop.resize(pattcount,LORGE);
        OptionState::prune_mindispx.resize(pattcount,SMOLL);
        OptionState::prune_maxdispx.resize(pattcount,LORGE);
        OptionState::prune_mindispy.resize(pattcount,SMOLL);
        OptionState::prune_maxdispy.resize(pattcount,LORGE);
        OptionState::prune_mincomm.resize(pattcount,0);
        OptionState::prune_maxcomm.resize(pattcount,TRANSCOUNT);
        OptionState::filter_minpop.resize(pattcount,0);
        OptionState::filter_maxpop.resize(pattcount,LORGE);
        OptionState::filter_mindispx.resize(pattcount,SMOLL);
        OptionState::filter_maxdispx.resize(pattcount,LORGE);
        OptionState::filter_mindispy.resize(pattcount,SMOLL);
        OptionState::filter_maxdispy.resize(pattcount,LORGE);
        OptionState::filter_mincomm.resize(pattcount,0);
        OptionState::filter_maxcomm.resize(pattcount,TRANSCOUNT);

        #ifndef CHECKFRONTEND
        for(auto i: OptionState::noexp)
        {
            if(i)
            {
                cout<<"NOTE: Explosion detection undefined for this rulespace, ignoring flag."<<endl;
                break;
            }
        }
        #endif

        if(OptionState::filename=="")OptionState::filename="EPEOutput.txt";
        if(OptionState::reporting_interval==0) OptionState::reporting_interval=5000000;

        return;
    }
    exit(1);
}